<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <title>Blockem. Artificial Intelligence</title>
  <meta content="Faustino Frechilla" name="author">
  <meta content="Blockem project page. Artificial Intelligence" name="description">
  <meta content="blockem blokus board game freeware free download gratis gnu gpl heuristics artificial intelligence minimax alpha-beta prunning" name="keywords">
  <meta content="all" name="robots">
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta name="generator" content="Bluefish 1.0.7">
  <link rel="shortcut icon" href="../images/blockemicon.ico" type="image/x-icon" />
  <!-- css style -->
  <style  type="text/css">
    a:link {
        color: #453b77;
    }
    a:visited {
        color: #453b77;
    }
    a:hover{
        color: #453b77;
        background-color: #fde72d;
    }
    a:active {
        color: #453b77;
    }
    a {
        text-decoration: underline;
    }
  </style>
  
  </head>

<body style="background-color: rgb(255, 216, 165);">
<table align="center" border="0" cellpadding="5" width="95%">
  <tbody>
    <tr>
      <td valign="top" width="25%" align="right"><a href="http://blockem.sourceforge.net/" style="text-decoration:none; background-color: #ffd8a5">
              <img alt="blockem icon" src="../images/blockemlogo128.png" border="0"></a>
      </td>
      <td align="left" width="75%"valign="vcenter"><a href="http://blockem.sourceforge.net/" style="text-decoration:none">
        <h1> Blockem</h1></a>
      </td>
    </tr>
    <tr>
      <td valign="top" width="25%">
      <br/>
      <p align="center"><img alt="blockem game" src="../images/screenshot.jpg" border="0"></p>
      <p align="center">Blockem is <a href="http://www.fsf.org/">free software</a> released under GNU GPL v3</p>
      <p></p>
      <br/>
      <p align="center"><font size="+1"><a href="http://blockem.sourceforge.net/index.html#download">Download</a></font> blockem...</p>
      <p align="center">... or have a look at the <a href="http://sourceforge.net/project/screenshots.php?group_id=302382">screenshots</a></p>
      <p><br/></p>
      </td>
      <td>
      <p align="left"><h2>Customising blockem artificial intelligence</h2></p>
      <p>
      To understand the Artifical intelligence (AI) used in Blockem, a few terms must
      be understood first:
      <ul>
        <li>Game tree (from <a href="http://en.wikipedia.org/wiki/Game_tree">wikipedia</a>) is a directed graph whose nodes are positions in a 
  game and whose edges are moves. The complete game tree for a game is the game 
  tree starting at the initial position and containing all possible moves from 
  each position.</li>
        <li>Minimax (from <a href="http://en.wikipedia.org/wiki/Minimax">wikipedia</a>) is a decision rule used in game theory (...) for 
  minimising the possible loss while maximising the potential gain</li>
        <li>Alpha-beta prunning (from <a href="http://en.wikipedia.org/wiki/Alpha-beta_pruning">wikipedia</a>) It is a search with adversary algorithm
  used commonly for machine playing of two-player games (Tic-tac-toe, Chess, 
  Go, etc.). It seeks to reduce the number of nodes that are evaluated in the 
  search tree by the minimax algorithm</li>
      </ul>
      </p>


<p>As you could have guessed, Blockem AI is based on the MiniMax algorithm with 
alpha-beta prunning, to reduce the number of nodes in the search tree ensuring 
the same result as it would be got with Minimax.</p>

<p>The big deal about the Minimax-alphabeta algorithm is the evaluation function, 
which gives a numeric value to a specific configuration of the game. In blockem
the configuration of the game is defined by the board, the moving player and the
opponent, so the C++ interface of the evaluation function was decided to be:</p>
<code>
int32_t EvalFunction(<br/>
&nbsp;&nbsp;const Board  &a_board,<br/>
&nbsp;&nbsp;const Player &a_playerMe,<br/>
&nbsp;&nbsp;const Player &a_playerOpponent);<br/>
</code>
<p>
Inside a class called Heuristic (in heuristic.h) there's a typedef which 
defines exactly this interface:</p>
<code>class Heuristic<br/>
{<br/>
<br/>
&nbsp;&nbsp;/* ... */<br/>
&nbsp;&nbsp;typedef int32_t (*EvalFunction_t)(const Board &, const Player &, const Player &);<br/>
&nbsp;&nbsp;/* ... */<br/>
<br/>
}<br/>
</code>

<p>You can easily write a new heuristic and make it available in the blockem GUI. 
The following explanation applies to blockem version 0.2.0 or higher, where
the process of adding new heuristics has been improved and simplified.</p>
<ol>
<li><p>Implement a function that suits the 'EvalFunction' Interface. A very 
    obvious one (though too simple) might be based on the number of squares
    each player managed to allocate on the board:</p>
 <code>
&nbsp;&nbsp;int32_t SimpleEvalFunction(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Board  &a_board,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Player &a_playerMe,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Player &a_playerOpponent)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t squaresMe = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t squaresOpponent = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t rv = 0;<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (uint8_t rowCount = 0; rowCount < a_board.GetNRows() ; rowCount++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (uint8_t columnCount = 0; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columnCount <  a_board.GetNColumns(); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columnCount++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a_board.IsPlayerInCoord(rowCount, columnCount, a_playerMe))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;squaresMe++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (a_board.IsPlayerInCoord(rowCount, columnCount, a_playerOpponent))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;squaresOpponent++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv += squaresMe;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv -= squaresOpponent;<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;return rv;<br/>
&nbsp;&nbsp;}<br/>
</code>
<p>
    If we take the former heuristic as the base one, we can slightly improve 
    its performance taking into account also the nucleation points. The 
    following code is the heuristic called "Simple" in the configuration
    dialog. It assigns twice as much of importance to create a new nucleation
    point than removing one from the opponent. You could easily adapt this
    heuristic to something that is only focused on stopping the opponent, 
    or vice-versa</p>
    
 <code>
&nbsp;&nbsp;int32_t SimpleEvalFunction(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Board  &a_board,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Player &a_playerMe,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;const Player &a_playerOpponent)<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t squaresMe = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t squaresOpponent = 0;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;int32_t rv = 0;<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;for (uint8_t rowCount = 0; rowCount < a_board.GetNRows() ; rowCount++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (uint8_t columnCount = 0; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columnCount <  a_board.GetNColumns(); <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columnCount++)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (a_board.IsPlayerInCoord(rowCount, columnCount, a_playerMe))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;squaresMe++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (a_board.IsPlayerInCoord(rowCount, columnCount, a_playerOpponent))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;squaresOpponent++;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv += squaresMe*4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv += a_playerMe.NumberOfNucleationPoints()*2;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv -= squaresOpponent*4;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;rv -= a_playerOpponent.NumberOfNucleationPoints();<br/>
   <br/>
&nbsp;&nbsp;&nbsp;&nbsp;return rv;<br/>
&nbsp;&nbsp;}<br/>
</code>
<p> All the available heuristics are added to an array defined in the Heuristic
    class called m_heuristicData. This array is defined in heuristic.h as:Have a look at heuristic.cpp and heuristic.h to see more examples of 
    already implemented heuristics. There are a few functions defined in 
    rules.h that might help you out to write a powerful evaluation function 
    (things like IsThisANucleationPoint, and so on...)</p>
 </li>
<li><p>All the available heuristics are added to an array defined in the Heuristic
    class called m_heuristicData. This array is defined in heuristic.h as:</p>
<code>
&nbsp;&nbsp;/// types of heuristic<br/>
&nbsp;&nbsp;typedef enum<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicStartCount = 0, // this element must be always 0 and must be at the start<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicNKWeighted = e_heuristicStartCount,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicRandom,<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicCount, // stores the amount of heuristics. Must be always at the end<br/>
&nbsp;&nbsp;} eHeuristicType_t;<br/>
<br/>
&nbsp;&nbsp;/// heuristic data to be used in the heuristics config array<br/>
&nbsp;&nbsp;typedef struct<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;eHeuristicType_t m_type;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;EvalFunction_t m_evalFunction;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string m_name;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string m_description;<br/>
&nbsp;&nbsp;} sHeuristicData_t;<br/>
<br/>
&nbsp;&nbsp;static const sHeuristicData_t m_heuristicData[e_heuristicCount];<br/>
</code>
<p>At the top of heuristic.cpp the list of available heuristic is instantiated:</p>
<code>
&nbsp;&nbsp;// instantiate the const heuristic data array. Heuristics must be defined here<br/>
&nbsp;&nbsp;// in the same order they are described in Heuristic::eHeuristicType_t in heuristic.h<br/>
&nbsp;&nbsp;const Heuristic::sHeuristicData_t Heuristic::m_heuristicData[e_heuristicCount] =<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicNKWeighted,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateNKWeighted,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("NK weighted"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Nucleation points are weighted. The more in the middle in the board a NK point is, the more important it is")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Simple"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Takes into account only the amount of squares of the deployed pieces")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicRandom,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateRandom,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Random"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Random heuristic. Evaluation function returns a random value so any heuristic can be checked against it")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;};<br/>
</code>
<p>    To add a brand new Heuristic in a function called, for example, 
    "MyCustomisedHeuristic", first of all you must add an entry in the 
    eHeuristicType_t enum in heuristic.h</p>
<code>
&nbsp;&nbsp;/// types of heuristic<br/>
&nbsp;&nbsp;typedef enum<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicStartCount = 0, // this element must be always 0 and must be at the start<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicNKWeighted = e_heuristicStartCount,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicRandom,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicMyCustomisedHeuristic, // <-- Your brand new heuristic<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_heuristicCount, // stores the amount of heuristics. Must be always at the end<br/>
&nbsp;&nbsp;} eHeuristicType_t;<br/>
</code>
<p>And then add it to the m_heuristicData array in heuristic.cpp:</p>
<code>
&nbsp;&nbsp;// instantiate the const heuristic data array. Heuristics must be defined here<br/>
&nbsp;&nbsp;// in the same order they are described in Heuristic::eHeuristicType_t in heuristic.h<br/>
&nbsp;&nbsp;const Heuristic::sHeuristicData_t Heuristic::m_heuristicData[e_heuristicCount] =<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicNKWeighted,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateNKWeighted,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("NK weighted"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Nucleation points are weighted. The more in the middle in the board a NK point is, the more important it is")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateSimple,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Simple"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Takes into account only the amount of squares of the deployed pieces")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicRandom,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Heuristic::CalculateRandom,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Random"),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("Random heuristic. Evaluation function returns a random value so any heuristic can be checked against it")<br/>
&nbsp;&nbsp;&nbsp;&nbsp;},<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{e_heuristicMyCustomisedHeuristic,      // as defined in eHeuristicType_t in heuristic.h<br/>
&nbsp;&nbsp;&nbsp;&nbsp;MyCustomisedHeuristic,                 // pointer to the heuristic function you wrote<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("MyCustomised"),           // Name of the heuristic. It'll be used in the GUI<br/>
&nbsp;&nbsp;&nbsp;&nbsp;std::string("This is my brand new...") // Description of your heuristic. It'll also be used in the GUI<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;};<br/>
</code>
</li>
<li>
<p>Save all the changes, recompile blockem and your heuristic will be 
    magically available to be selected in the "new Game" and the "configuration"
    menu. You will be able to test your new heuristic against the "random" one,
    or try to beat it playing blockem in a 1vs1 game
</p>
</li>
</ol>
<p><br/></p>
<p align="left"><h2>Undestanding depth of the search tree</h2></p>

<p>The depth of the search tree is set by default to 3, unless the player has less
than 14 pieces left. The depth of the search tree defines how many pieces are 
"virtually" put down by the minmax algorithm to test how good a specific move. 
Depth 3 means minmax will put down a piece of the player whose move is being 
calculated, then it will put down a piece of the opponent (normally the human
user) and finally another piece of the player whole move is being calculated. 
Once this is done the evaluation function is calculated and the value returned 
is used to "tag" this particular move. That set of 3 moves which maximises the 
minmax algorithm at the end of the whole process is picked as winner, and the 
move returned by the MinMax algorithm will be the corresponding first move of 
the set.</p>

<p>Minimum depth possible is 1, where no futurising is done. Evaluation function 
is calculated after puting down a piece by the user whose move is being 
calculated. On the contrary, depth 5 means 3 pieces of the "computer" player 
and 2 of the "human" one will be place on the board before the evaluation 
method is run.</p>
   
<p>Depth can also be set to an even number, though it is discouraged because 
better results have been observed using an odd number. This is due to the fact 
that an odd number maximises the current user, instead of trying to minimise 
the opponent.</p>
   
<p>Obviously, the deeper you calculate the search tree, the better. But if the
search tree is too big, for instance because there are too many pieces left,
computing a new depth for the search tree is very expensive in time, which can 
be bad for the user experience.</p>

<p>Let's use an example to explain it: At the beginning of the game each player 
has 21 pieces left. Since placing this 1st piece on the board has different 
rules than the rest of the pieces, let's assume both players put down the 
simplest of the pieces, the baby piece (1 square). It has 4 nucleation 
points (corners).</p>
   
<p>If we set MinMax to calculate with depth = 1 it will call the evaluation 
function once per allowed movement in each nucleation point, that might be, 
roughly, 90 different configurations (20 pieces + rotated pieces + mirror 
pieces + rotated and mirrored pieces...) multiplied by 4 nucleation points 
equals 360 times. In reality it's even worse, because some pieces can be put 
down more than once with the same configuration in the same nucleation point 
(for instance, think of how many different ways you can place a the cross piece
next to a baby piece)</p>
   
<p>Let's assume there will be always around 360 different possibilities (as I said
it is even worse, there are several ways to deploy a piece in a nucleation 
point, and normally there are more than only 4 corners). Anyway, assuming this
beautiful world of "only 360", the next depth in the search tree will be 
360 * 360 = 129,600 (360 new configuration per each old possibility), and the 
following one (depth 3), will be 360*360*360 = 46,656,000!!!</p>

<p>The reality is that things are not that bad really, because the alpha beta 
prunning takes care of lots of different useless branches of the search tree 
before they are calculated, but this example shows why you must use the depth 
parameter with a lot of care.</p>
   
<p><br/></p>
<p align="left"><h2>Steps done (and some yet to be done) to improve heurisitics</h2></p>
   
<p>As it is described in the wikipedia about the alpha-beta prunning, "Further 
improvement can be achieved without sacrificing accuracy, by using ordering 
heuristics to search parts of the tree that are likely to force alpha-beta 
cutoffs early, For example, in chess, moves that take pieces may be examined 
before moves that do not".</p>
   
<p>To improve speed in the Blockem implementation of the alpha-beta prunning, 
bigger pieces are always checked before smaller ones (they are more likely to 
be better as an important part of the evaluation function must be the amount 
of squaresd eployed on the board). They are checked in inverse order as they 
are defined in ePieceType_t enum in Piece.h, so pieces in that enum are sorted
from worse to better (from less likely to do a good move to more likely):</p>
   
<code>
&nbsp;&nbsp;typedef enum<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;// if this enum is modified, ensure all the constants are updated <br/>
&nbsp;&nbsp;&nbsp;&nbsp;// accordingly<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_minimumPieceIndex = 0,<br/>
       <br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_1Piece_BabyPiece   = e_minimumPieceIndex,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_2Piece_TwoPiece    = 1,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_3Piece_LongPiece   = 2,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;/* ... */<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_5Piece_TheUltimate = 20,<br/>
       <br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_numberOfPieces = 21,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;e_noPiece = 22,   <br/>
&nbsp;&nbsp;} ePieceType_t;<br/>
</code>
   
<p>Another design step was made to trim out possibly useless branches of the 
search tree. It sacrifices a bit of accuracy assuming no 4,3,2 or 1 square 
pieces are put down before the 6th move. Obviously Assume makes an ass out of 
u and me, but sometimes assumptions must be made. A constant has been defined 
in game1v1.cpp (MIN_5SQUARE_PIECES_AT_START) which describes how many 5-square 
pieces will be put in-a-row before even considering to put a 4,3,2 or 1 square 
piece on the board.</p>

<p>Computing speed has been also improved using tools as gprof to understand 
where the biggest amount of computing was being spent. It doesn't mean it's 
perfect though. Pieces are at the moment described as arrays of coordinates, 
while describing them as pure bits in a uint32_t o(or uint64_t) would improve 
calculation speed (at least that is what I think). Also the calculation 
algorithm is not multithreaded, though building up a search tree looks like a 
good (and relatively easy) thing to be multithreaded.</p>
 
<p>And that pretty much describes what I've done so far regarding the heuristics
in blockem. If you think this may be of your interest, code away and have fun! 
(and if you improve it, please share it with me!)</p>
</table>

<hr>
<table align="center" border="0" cellpadding="5" width="95%">
  <tbody>
    <tr>
      <td align="left" width="50%">
        <p>
        <small>
          Copyright (c) 2009-<script type="text/javascript">var d = new Date();document.write(d.getFullYear());</script>. <a href="http://www.sourceforge.net/sendmessage.php?touser=743915">Faustino Frechilla</a><br>Last modified: 13th May 2010
        </small> 
        </p>
      </td>
      <td align="right" width="50%">
      <a rel="license" href="http://creativecommons.org/licenses/by/3.0/es/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/es/88x31.png" /></a>
      &nbsp;
      <a href="http://sourceforge.net/projects/blockem"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=302382&amp;type=3" alt="SourceForge.net" /></a>
      </td>
    </tr>
  </tbody>
</table>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-16028570-1");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
